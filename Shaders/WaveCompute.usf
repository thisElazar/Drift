// WaveCompute.usf
// GPU-based wave computation for vertex displacement water system
// FIXED: Added proper amplitude limiting and depth-based constraints

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// ===== SHADER PARAMETERS =====
// Input textures
Texture2D<float> WaterDepthTexture;
Texture2D<float4> FlowDataTexture;

// Output texture
RWTexture2D<float4> WaveOutputTexture;

// Simulation parameters
float Time;
float4 WindParams;  // xy = direction, z = strength, w = unused
float4 WaveParams;  // x = wave scale, y = wave speed, z = dampening, w = terrain scale
float4 TerrainParams;  // xy = terrain dimensions, zw = unused

// Sampler for texture reads
SamplerState TextureSampler;

// ===== CONSTANTS =====
#define MIN_WATER_DEPTH 0.01f
#define MAX_WAVE_HEIGHT_RATIO 0.3f  // Waves can't exceed 30% of depth
#define SAFE_WAVE_HEIGHT_RATIO 0.125f  // Conservative limit: 12.5% of depth
#define DEEP_WATER_THRESHOLD 50.0f
#define SHALLOW_WATER_THRESHOLD 5.0f
#define TWO_PI 6.28318530718f

// ===== HELPER FUNCTIONS =====

// Calculate proper depth attenuation with deep water limiting
float CalculateDepthAttenuation(float WaterDepth)
{
    if (WaterDepth < SHALLOW_WATER_THRESHOLD)
    {
        // Shallow water - waves attenuate with depth
        return saturate(WaterDepth / SHALLOW_WATER_THRESHOLD);
    }
    else if (WaterDepth > DEEP_WATER_THRESHOLD)
    {
        // Deep water - waves stabilize and don't grow infinitely
        // Gradual reduction prevents unbounded growth
        float deepFactor = (WaterDepth - DEEP_WATER_THRESHOLD) / DEEP_WATER_THRESHOLD;
        return 1.0f / (1.0f + deepFactor * 0.5f);
    }
    else
    {
        // Transition zone - full wave development
        return 1.0f;
    }
}

// Calculate Froude number for flow regime detection
float CalculateFroudeNumber(float FlowSpeed, float WaterDepth)
{
    if (WaterDepth < MIN_WATER_DEPTH)
        return 0.0f;
    
    // Fr = V / sqrt(g * h)
    // Using 981 cm/s^2 for gravity (UE units)
    float sqrtGH = sqrt(981.0f * WaterDepth);
    return FlowSpeed / max(sqrtGH, 0.001f);
}

/**
 * Generate physically-based wind-driven waves with dispersion
 * Uses deep-water dispersion relation: c = sqrt(g*lambda/(2*pi))
 */
float CalculateWindWaves(float2 WorldPos, float WaterDepth, float WindStrength,
                         float2 WindDirection, float Time)
{
    // Early exit for no wind
    if (WindStrength < 0.01f)
        return 0.0f;
    
    // Physical constraint: waves shouldn't exceed percentage of water depth
    float depthLimit = WaterDepth * MAX_WAVE_HEIGHT_RATIO;
    float windLimit = WindStrength * 0.05f;
    float maxWaveHeight = min(depthLimit, windLimit);
    
    // Very shallow water gets conservative limit
    if (WaterDepth < 1.0f)
        maxWaveHeight = WaterDepth * 0.1f;
    
    // Multiple wave components with different wavelengths
    float WaveHeight = 0.0f;
    
    // Primary wind waves (long wavelength)
    float lambda1 = 200.0f * WindStrength; // Wavelength scales with wind
    float k1 = TWO_PI / lambda1;           // Wave number
    float omega1 = sqrt(981.0f * k1 * tanh(k1 * WaterDepth)); // Dispersion relation
    float phase1 = dot(WorldPos, WindDirection) * k1 - omega1 * Time;
    float amp1 = maxWaveHeight * 0.6f;
    WaveHeight += amp1 * sin(phase1);
    
    // Secondary waves (medium wavelength, 30° off wind)
    float2 windDir2 = float2(
        WindDirection.x * cos(0.52f) - WindDirection.y * sin(0.52f),
        WindDirection.x * sin(0.52f) + WindDirection.y * cos(0.52f)
    );
    float lambda2 = 80.0f * WindStrength;
    float k2 = TWO_PI / lambda2;
    float omega2 = sqrt(981.0f * k2 * tanh(k2 * WaterDepth));
    float phase2 = dot(WorldPos, windDir2) * k2 - omega2 * Time;
    float amp2 = maxWaveHeight * 0.3f;
    WaveHeight += amp2 * sin(phase2);
    
    // Tertiary waves (short wavelength, capillary)
    float lambda3 = 30.0f;
    float k3 = TWO_PI / lambda3;
    float omega3 = sqrt((981.0f * k3 + 0.074f * k3 * k3 * k3) * tanh(k3 * WaterDepth)); // Surface tension
    float phase3 = dot(WorldPos, WindDirection) * k3 - omega3 * Time * 1.3f;
    float amp3 = maxWaveHeight * 0.1f;
    WaveHeight += amp3 * sin(phase3);
    
    // Apply depth-dependent attenuation
    float depthAtten = CalculateDepthAttenuation(WaterDepth);
    WaveHeight *= depthAtten;
    
    // Final safety clamp
    float safeLimit = WaterDepth * SAFE_WAVE_HEIGHT_RATIO;
    WaveHeight = clamp(WaveHeight, -safeLimit, safeLimit);
    
    return WaveHeight;
}

/**
 * Generate waves from water flow interactions with terrain
 * Creates standing waves (hydraulic jumps) and flow perturbations
 */
float CalculateFlowWaves(float2 WorldPos, float WaterDepth, float2 FlowVector,
                         float FlowSpeed, float Time)
{
    // Early exit for still water
    if (FlowSpeed < 0.1f)
        return 0.0f;
    
    // Calculate Froude number
    float Fr = CalculateFroudeNumber(FlowSpeed, WaterDepth);
    
    // Subcritical flow (Fr < 1): gentle waves
    // Supercritical flow (Fr > 1): shock waves
    
    float WaveHeight = 0.0f;
    
    if (Fr < 0.7f) // Subcritical - smooth flow
    {
        // Gentle undulations in flow direction
        float2 flowDir = normalize(FlowVector + float2(0.001f, 0.001f));
        float flowPhase = dot(WorldPos, flowDir) * 0.02f - Time * FlowSpeed * 0.1f;
        WaveHeight = sin(flowPhase) * WaterDepth * 0.05f * Fr;
    }
    else if (Fr > 1.2f) // Supercritical - shock waves
    {
        // Standing waves form perpendicular to flow
        float2 flowDir = normalize(FlowVector + float2(0.001f, 0.001f));
        float2 perpDir = float2(-flowDir.y, flowDir.x);
        
        // Hydraulic jump wavelength scales with depth
        float jumpWavelength = WaterDepth * 8.0f;
        float jumpPhase = dot(WorldPos, flowDir) / jumpWavelength * TWO_PI;
        
        // Amplitude grows with Froude number excess
        float shockStrength = (Fr - 1.0f) * 0.5f;
        WaveHeight = sin(jumpPhase) * WaterDepth * shockStrength;
        
        // Add perpendicular oscillations
        float perpPhase = dot(WorldPos, perpDir) * 0.05f + Time * 0.5f;
        WaveHeight += cos(perpPhase) * WaterDepth * 0.1f * shockStrength;
    }
    else // Transition region (0.7 < Fr < 1.2)
    {
        // Blend between subcritical and supercritical
        float blendFactor = (Fr - 0.7f) / 0.5f;
        
        // Subcritical component
        float2 flowDir = normalize(FlowVector + float2(0.001f, 0.001f));
        float subPhase = dot(WorldPos, flowDir) * 0.02f - Time * FlowSpeed * 0.1f;
        float subWave = sin(subPhase) * WaterDepth * 0.05f * Fr;
        
        // Supercritical component
        float superPhase = dot(WorldPos, flowDir) * 0.05f;
        float superWave = sin(superPhase) * WaterDepth * 0.15f;
        
        WaveHeight = lerp(subWave, superWave, blendFactor);
    }
    
    // Clamp to safe limits
    float safeLimit = WaterDepth * SAFE_WAVE_HEIGHT_RATIO;
    return clamp(WaveHeight, -safeLimit, safeLimit);
}

/**
 * Generate waves from flow collisions and turbulence
 * Detects velocity divergence to create splash patterns
 */
float CalculateCollisionWaves(float2 WorldPos, float2 FlowVector,
                              float WaterDepth, float Time)
{
    // This requires sampling neighboring flow velocities
    // For now, use simplified turbulence model based on flow curvature
    
    float FlowSpeed = length(FlowVector);
    if (FlowSpeed < 0.5f)
        return 0.0f;
    
    // Generate turbulent waves using flow-modulated noise
    float2 flowDir = normalize(FlowVector + float2(0.001f, 0.001f));
    
    // Turbulence scale decreases with flow speed (faster = smaller eddies)
    float turbScale = 50.0f / (1.0f + FlowSpeed * 0.5f);
    
    // Rotate sampling by flow direction for directional turbulence
    float angle = atan2(flowDir.y, flowDir.x);
    float2 rotatedPos = float2(
        WorldPos.x * cos(angle) - WorldPos.y * sin(angle),
        WorldPos.x * sin(angle) + WorldPos.y * cos(angle)
    );
    
    // Multi-scale turbulent noise
    float noise1 = sin(rotatedPos.x / turbScale + Time * FlowSpeed * 0.2f) *
                   cos(rotatedPos.y / turbScale - Time * FlowSpeed * 0.15f);
    float noise2 = sin(rotatedPos.x / (turbScale * 0.5f) - Time * FlowSpeed * 0.4f) *
                   cos(rotatedPos.y / (turbScale * 0.5f) + Time * FlowSpeed * 0.3f);
    
    float turbulence = (noise1 * 0.7f + noise2 * 0.3f);
    
    // Amplitude scales with flow speed but limited by depth
    float amplitude = min(FlowSpeed * 0.02f, WaterDepth * 0.08f);
    float WaveHeight = turbulence * amplitude;
    
    // Clamp to safe limits
    float safeLimit = WaterDepth * SAFE_WAVE_HEIGHT_RATIO;
    return clamp(WaveHeight, -safeLimit, safeLimit);
}

/**
 * Combine multiple wave sources using energy conservation
 * Non-linear combination prevents unrealistic amplitude stacking
 */
float CombineWaveComponents(float windWave, float flowWave,
                            float collisionWave, float baseNoise)
{
    // Simple linear combination causes amplitude blowup
    // Instead, use root-mean-square (energy-based combination)
    
    // Method 1: RMS Combination (Energy-conserving)
    // E_total = E_wind + E_flow + E_collision
    // Since E ∝ A², we have: A_total = sqrt(A_wind² + A_flow² + ...)
    float energySum = windWave * windWave +
                      flowWave * flowWave +
                      collisionWave * collisionWave;
    float rmsAmplitude = sqrt(energySum);
    
    // Preserve sign of dominant component
    float dominantSign = sign(windWave); // Wind usually dominates
    if (abs(flowWave) > abs(windWave))
        dominantSign = sign(flowWave);
    
    float combinedWave = dominantSign * rmsAmplitude;
    
    // Add base noise additively (it's already very small)
    combinedWave += baseNoise;
    
    // Alternative Method 2: Weighted Linear (simpler, less physical)
    // Uncomment if RMS causes issues:
    // float combinedWave = windWave * 0.6f + flowWave * 0.3f +
    //                      collisionWave * 0.1f + baseNoise;
    
    return combinedWave;
}

/**
 * Final amplitude validation and physical constraint enforcement
 * Ensures waves never exceed breaking limit or depth constraints
 */
float ApplyAmplitudeLimits(float WaveHeight, float WaterDepth, float WindStrength)
{
    // Breaking wave limit: H/lambda > 1/7 (Miche criterion)
    // For our wavelengths, this translates to H < depth * 0.4
    float breakingLimit = WaterDepth * 0.4f;
    
    // Conservative operational limit (30% of depth)
    float operationalLimit = WaterDepth * MAX_WAVE_HEIGHT_RATIO;
    
    // Very shallow water needs even stricter limits
    float shallowLimit = WaterDepth * SAFE_WAVE_HEIGHT_RATIO;
    if (WaterDepth < 2.0f)
        operationalLimit = shallowLimit;
    
    // Wind can't generate waves larger than fetch allows
    // Simplified: wave height limited by wind strength
    float windLimit = WindStrength * 0.1f; // 10cm per m/s of wind
    
    // Apply most restrictive limit
    float finalLimit = min(operationalLimit, min(breakingLimit, windLimit));
    
    // Symmetric clamping
    WaveHeight = clamp(WaveHeight, -finalLimit, finalLimit);
    
    // Sanity check: absolute maximum regardless of conditions
    float absoluteMax = min(WaterDepth * 0.5f, 10.0f); // Never more than 50% depth or 10m
    WaveHeight = clamp(WaveHeight, -absoluteMax, absoluteMax);
    
    return WaveHeight;
}

// ===== MAIN COMPUTE FUNCTION =====
[numthreads(8, 8, 1)]
void WaveComputeCS(uint3 id : SV_DispatchThreadID)
{
    // Get texture dimensions
    uint2 TextureDims;
    WaveOutputTexture.GetDimensions(TextureDims.x, TextureDims.y);
    
    // Bounds check
    if (id.x >= TextureDims.x || id.y >= TextureDims.y)
        return;
    
    // Calculate UV coordinates
    float2 UV = float2(id.xy) / float2(TextureDims);
    
    // Sample input data
    uint2 PixelCoord = id.xy;
    float WaterDepth = WaterDepthTexture.Load(uint3(PixelCoord, 0)).r;
    float4 FlowData = FlowDataTexture.Load(uint3(PixelCoord, 0));
    
    // Early out for no water
    if (WaterDepth < MIN_WATER_DEPTH)
    {
        WaveOutputTexture[id.xy] = float4(0, 0, 0, 0);
        return;
    }
    
    // Convert to world position
    float2 WorldPos = UV * TerrainParams.xy * WaveParams.w;
    
    // Extract flow parameters
    float2 FlowVector = FlowData.xy;
    float FlowSpeed = length(FlowVector);
    float FoamIntensity = FlowData.w;
    
    // Wind parameters
    float2 WindDirection = normalize(WindParams.xy + float2(0.001f, 0.001f));
    float WindStrength = WindParams.z;
    
    // ===== CALCULATE INDIVIDUAL WAVE COMPONENTS =====
    
    float windWave = 0.0f;
    float flowWave = 0.0f;
    float collisionWave = 0.0f;
    float baseNoise = 0.0f;
    
    // 1. Wind-driven waves
    if (WindStrength > 0.1f)
    {
        windWave = CalculateWindWaves(WorldPos, WaterDepth, WindStrength, WindDirection, Time);
    }
    
    // 2. Flow-driven waves
    if (FlowSpeed > 0.1f)
    {
        flowWave = CalculateFlowWaves(WorldPos, WaterDepth, FlowVector, FlowSpeed, Time);
    }
    
    // 3. Collision waves
    collisionWave = CalculateCollisionWaves(WorldPos, FlowVector, WaterDepth, Time);
    
    // 4. Base noise for realism (small amplitude)
    float noiseAmplitude = min(WaterDepth * 0.01f, 0.1f);  // Very small, max 1% of depth
    baseNoise = sin(WorldPos.x * 0.1f + Time * 0.5f) * cos(WorldPos.y * 0.15f - Time * 0.3f) * noiseAmplitude;
    
    // ===== COMBINE WAVES WITH ENERGY CONSERVATION =====
    
    float WaveHeight = CombineWaveComponents(windWave, flowWave, collisionWave, baseNoise);
    
    // ===== APPLY FINAL AMPLITUDE CONSTRAINTS =====
    
    WaveHeight = ApplyAmplitudeLimits(WaveHeight, WaterDepth, WindStrength);
    
    // ===== CALCULATE ADDITIONAL OUTPUT DATA =====
    
    // Calculate wave normal gradient for displacement
    float2 gradient = float2(
        sin(WorldPos.x * 0.02f + Time) * 0.05f,  // Reduced from 0.1f
        cos(WorldPos.y * 0.02f + Time) * 0.05f
    );
    
    // Scale gradient by wave height
    gradient *= saturate(abs(WaveHeight) / (WaterDepth * 0.1f));
    
    // Calculate foam intensity
    float waveDerivative = abs(windWave - flowWave);  // Wave interaction creates foam
    float foamFromWaves = saturate(waveDerivative / (WaterDepth * 0.05f));
    float totalFoam = saturate(FoamIntensity + foamFromWaves + abs(collisionWave) * 2.0f);
    
    // Output: R=height, G=depth for blending, B=flow speed, A=foam
    WaveOutputTexture[id.xy] = float4(
        WaveHeight,
        WaterDepth,
        FlowSpeed,
        totalFoam
    );
}
