// WaveCompute.usf - Phase 1: Unified Water Physics with Wave Energy Propagation
// GPU-based wave computation + wave energy propagation + vorticity caching
// PHASE 1: Wave energy system with fetch/seiche emergence
// PHASE 1.5: Pressure-gradient waves + displacement detection (splashing/sloshing)
// PHASE 2: Will add persistent foam and advanced coupling

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// ===== SHADER PARAMETERS =====
// Input textures
Texture2D<float> WaterDepthTexture;
Texture2D<float> PreviousDepthTexture;  // PHASE 1.5: For displacement detection
Texture2D<float> TerrainHeightTexture;  // PHASE 1.5: For pressure gradient
RWTexture2D<float4> FlowDataTexture;  // NOW READ/WRITE for wave energy + vorticity
Texture2D<float4> AtmosphereStateTexture;

// Output texture
RWTexture2D<float4> WaveOutputTexture;

// Simulation parameters
float Time;
float DeltaTime;  // NEW: Need time delta for propagation
float4 WindParams;  // xy = direction, z = strength, w = unused
float4 WaveParams;  // x = scale, y = speed, z = damping, w = groupVelMultiplier
float4 TerrainParams;  // xy = terrain dimensions, zw = unused

// Sampler for texture reads
SamplerState TextureSampler;

// ===== CONSTANTS =====
#define GRAVITY 981.0f
#define WATER_DENSITY 1000.0f
#define MIN_DEPTH 0.01f
#define DEEP_WATER_THRESHOLD 50.0f
#define SHALLOW_WATER_THRESHOLD 5.0f
#define TWO_PI 6.28318530718f

// Wave breaking constants (preserved from original)
#define BREAKING_STEEPNESS 0.14f
#define BREAKING_DISSIPATION 0.85f
#define BREAKING_FOAM_BOOST 3.0f
#define BREAKING_TURBULENCE 0.25f

// PHASE 1.5: Pressure wave constants
#define PRESSURE_WAVE_STRENGTH 0.8f    // How much pressure gradients drive waves
#define DISPLACEMENT_SENSITIVITY 2.0f  // Sensitivity to depth changes
#define DISPLACEMENT_ENERGY_SCALE 50.0f // Energy generated per unit displacement
#define SLOSH_REFLECTION_BOOST 0.5f    // Extra energy when waves hit walls

// ===== HELPER FUNCTIONS =====

// PHASE 1.5: Calculate water surface gradient (pressure gradient)
// Water surface = terrain height + water depth
// Pressure drives flow from high to low surface
float2 CalculateSurfaceGradient(int2 coord, int2 gridSize)
{
    if (coord.x < 1 || coord.x >= gridSize.x - 1 ||
        coord.y < 1 || coord.y >= gridSize.y - 1)
        return float2(0, 0);

    // Sample water surface height (terrain + depth) at neighbors
    float surfaceRight = TerrainHeightTexture[coord + int2(1, 0)].r + WaterDepthTexture[coord + int2(1, 0)].r;
    float surfaceLeft  = TerrainHeightTexture[coord + int2(-1, 0)].r + WaterDepthTexture[coord + int2(-1, 0)].r;
    float surfaceUp    = TerrainHeightTexture[coord + int2(0, -1)].r + WaterDepthTexture[coord + int2(0, -1)].r;
    float surfaceDown  = TerrainHeightTexture[coord + int2(0, 1)].r + WaterDepthTexture[coord + int2(0, 1)].r;

    // Gradient points from low to high (we want waves to go high to low)
    return float2(
        (surfaceRight - surfaceLeft) * 0.5f,
        (surfaceDown - surfaceUp) * 0.5f
    );
}

// PHASE 1.5: Detect water displacement (terrain rising/falling or water added/removed)
float CalculateDisplacement(int2 coord)
{
    float currentDepth = WaterDepthTexture[coord].r;
    float previousDepth = PreviousDepthTexture[coord].r;

    // Displacement = change in depth (positive = water pushed up, negative = water dropped)
    float displacement = currentDepth - previousDepth;

    return displacement;
}

// Calculate vorticity from velocity field (now cached in FlowDataTexture.A)
float CalculateVorticity(int2 coord, int2 gridSize)
{
    if (coord.x < 1 || coord.x >= gridSize.x - 1 ||
        coord.y < 1 || coord.y >= gridSize.y - 1)
        return 0.0f;
    
    // Read velocity from FlowDataTexture (channels R,G)
    float4 right = FlowDataTexture[coord + int2(1, 0)];
    float4 left  = FlowDataTexture[coord + int2(-1, 0)];
    float4 up    = FlowDataTexture[coord + int2(0, -1)];
    float4 down  = FlowDataTexture[coord + int2(0, 1)];
    
    float dVy_dx = (right.g - left.g) * 0.5f;
    float dVx_dy = (down.r - up.r) * 0.5f;
    
    return dVy_dx - dVx_dy;  // ω = ∂v/∂x - ∂u/∂y
}

// ============================================
// PHASE 1: UNIFIED WATER PHYSICS
// Entry point: WaveComputeCS (must match C++ registration)
// ============================================
[numthreads(8, 8, 1)]
void WaveComputeCS(uint3 ThreadId : SV_DispatchThreadID)
{
    int2 coord = ThreadId.xy;
    int2 gridSize = int2(TerrainParams.xy);
    
    if (coord.x >= gridSize.x || coord.y >= gridSize.y)
        return;
    
    // Read current state
    float depth = WaterDepthTexture[coord].r;
    float4 flowData = FlowDataTexture[coord];
    float2 velocity = flowData.rg;      // Mean flow velocity
    float waveEnergy = flowData.b;      // Wave energy density (Phase 1 NEW)
    float vorticity = flowData.a;       // Cached vorticity (Phase 1 NEW)
    
    if (depth < MIN_DEPTH)
    {
        // No water - zero everything
        FlowDataTexture[coord] = float4(0, 0, 0, 0);
        WaveOutputTexture[coord] = float4(0, 0, 0, 0);
        return;
    }
    
    // ==========================================
    // 1. UPDATE VORTICITY (cache for multiple uses)
    // ==========================================
    float newVorticity = CalculateVorticity(coord, gridSize);
    
    // Temporal smoothing to reduce jitter
    vorticity = lerp(vorticity, newVorticity, 0.3f);
    
    // Vorticity decay (viscous dissipation)
    vorticity *= 0.98f;
    
    // ==========================================
    // 2. WIND FORCING (Energy Source)
    // ==========================================
    float2 windDir = WindParams.xy;
    float windSpeed = WindParams.z;

    // Wind work on water surface: Power ∝ U³
    float windStress = windSpeed * windSpeed * windSpeed * 0.001f;
    float energyInput = windStress * DeltaTime;

    waveEnergy += energyInput;

    // ==========================================
    // 2.5 PRESSURE GRADIENT WAVES (PHASE 1.5)
    // ==========================================
    // Water surface slope creates pressure that drives waves
    float2 surfaceGradient = CalculateSurfaceGradient(coord, gridSize);
    float surfaceSlope = length(surfaceGradient);

    // Steeper slopes generate more wave energy (water wants to level out)
    float pressureEnergy = surfaceSlope * surfaceSlope * PRESSURE_WAVE_STRENGTH * depth;
    waveEnergy += pressureEnergy * DeltaTime;

    // ==========================================
    // 2.6 DISPLACEMENT WAVE GENERATION (PHASE 1.5)
    // ==========================================
    // Detect sudden changes in water depth (terrain pushed into water, water added, etc.)
    float displacement = CalculateDisplacement(coord);
    float absDisplacement = abs(displacement) * DISPLACEMENT_SENSITIVITY;

    // Significant displacement creates radial wave energy
    if (absDisplacement > 0.01f)
    {
        // Energy proportional to displacement squared (like kinetic energy)
        float displacementEnergy = absDisplacement * absDisplacement * DISPLACEMENT_ENERGY_SCALE;
        waveEnergy += displacementEnergy;

        // Displacement also creates vorticity (swirling)
        vorticity += displacement * 0.5f;
    }

    // ==========================================
    // 3. WAVE ENERGY PROPAGATION
    // ==========================================
    // Group velocity: cg = 0.5 * sqrt(g*h) for shallow water
    float groupVel = 0.5f * sqrt(GRAVITY * depth) * WaveParams.w;
    
    // Energy gradient (waves flow from high to low energy)
    float2 energyGradient = float2(0, 0);
    if (coord.x > 0 && coord.x < gridSize.x - 1 &&
        coord.y > 0 && coord.y < gridSize.y - 1)
    {
        float E_right = FlowDataTexture[coord + int2(1, 0)].b;
        float E_left  = FlowDataTexture[coord + int2(-1, 0)].b;
        float E_up    = FlowDataTexture[coord + int2(0, -1)].b;
        float E_down  = FlowDataTexture[coord + int2(0, 1)].b;
        
        energyGradient.x = (E_right - E_left) * 0.5f;
        energyGradient.y = (E_down - E_up) * 0.5f;
    }
    
    // Propagation direction = down-gradient + wind + flow advection + PRESSURE (PHASE 1.5)
    // Pressure gradient makes waves flow from high water surface to low
    float2 propagationDir = float2(0, 0);
    float2 pressureDirection = -surfaceGradient * PRESSURE_WAVE_STRENGTH;  // Waves go downhill

    if (length(energyGradient) > 0.001f || windSpeed > 0.1f || length(velocity) > 0.1f || surfaceSlope > 0.001f)
    {
        propagationDir = normalize(
            -energyGradient * 0.2f +      // Diffusion (reduced)
            windDir * windSpeed * 0.25f + // Wind forcing (reduced)
            velocity * 0.25f +            // Flow advection
            pressureDirection * 0.3f      // PHASE 1.5: Pressure-driven (waves flow to lower surface)
        );
    }
    
    // Diffusive propagation (waves spread out)
    float diffusion = groupVel * DeltaTime * 0.1f;
    
    // Sample upwind energy (simple advection)
    float2 upwindPos = float2(coord) - propagationDir * groupVel * DeltaTime;
    upwindPos = clamp(upwindPos, float2(1, 1), float2(gridSize.x - 2, gridSize.y - 2));
    
    int2 base = int2(upwindPos);
    float2 fracPart = frac(upwindPos);  // Renamed from 'frac' to 'fracPart'
    
    // Bilinear interpolation
    float E00 = FlowDataTexture[base + int2(0, 0)].b;
    float E10 = FlowDataTexture[base + int2(1, 0)].b;
    float E01 = FlowDataTexture[base + int2(0, 1)].b;
    float E11 = FlowDataTexture[base + int2(1, 1)].b;
    
    float advectedEnergy = lerp(
        lerp(E00, E10, fracPart.x),
        lerp(E01, E11, fracPart.x),
        fracPart.y
    );
    
    // Diffuse with neighbors
    float neighborEnergy = 0.0f;
    if (coord.x > 0 && coord.x < gridSize.x - 1 &&
        coord.y > 0 && coord.y < gridSize.y - 1)
    {
        float E_right = FlowDataTexture[coord + int2(1, 0)].b;
        float E_left  = FlowDataTexture[coord + int2(-1, 0)].b;
        float E_up    = FlowDataTexture[coord + int2(0, -1)].b;
        float E_down  = FlowDataTexture[coord + int2(0, 1)].b;
        neighborEnergy = (E_right + E_left + E_up + E_down) * 0.25f;
    }
    
    waveEnergy = lerp(advectedEnergy, neighborEnergy, diffusion);
    
    // ==========================================
    // 4. VORTICITY-WAVE COUPLING
    // ==========================================
    // Vortices refract waves (creates spiral patterns)
    float2 vorticityForce = float2(-vorticity, vorticity) * 0.1f;
    waveEnergy += dot(vorticityForce, energyGradient) * DeltaTime * abs(vorticity);
    
    // ==========================================
    // 5. WAVE BREAKING & ENERGY REDISTRIBUTION
    // ==========================================
    float waveHeight = sqrt(2.0f * waveEnergy / (WATER_DENSITY * GRAVITY));
    float maxWaveHeight = depth * 0.4f;  // H/h < 0.4 breaking limit
    
    float breakingEnergy = 0.0f;
    if (waveHeight > maxWaveHeight)
    {
        float excessEnergy = waveEnergy - 0.5f * WATER_DENSITY * GRAVITY * maxWaveHeight * maxWaveHeight;
        
        // Breaking redistributes energy:
        // - 40% → turbulence (adds to velocity fluctuations)
        // - 30% → horizontal momentum (radiation stress)
        // - 30% → dissipated as heat
        
        float2 breakingMomentum = propagationDir * sqrt(excessEnergy * 0.3f);
        velocity += breakingMomentum * DeltaTime;
        
        // Breaking generates vorticity (turbulent mixing)
        vorticity += sqrt(excessEnergy) * 0.1f;
        
        waveEnergy *= 0.7f;  // 30% dissipated
        breakingEnergy = excessEnergy * 0.3f;
    }
    
    // ==========================================
    // 6. RADIATION STRESS (Wave-Flow Coupling)
    // ==========================================
    // Waves push water in propagation direction
    float radiationStress = waveEnergy / max(depth, 1.0f);
    float2 waveForcingOnFlow = propagationDir * radiationStress * 0.15f;
    velocity += waveForcingOnFlow * DeltaTime;
    
    // ==========================================
    // 7. BOUNDARY REFLECTION (Shores)
    // ==========================================
    bool nearShore = false;
    float2 shoreNormal = float2(0, 0);
    int neighborCount = 0;
    
    for (int dy = -1; dy <= 1; dy++)
    {
        for (int dx = -1; dx <= 1; dx++)
        {
            if (dx == 0 && dy == 0) continue;
            
            int2 neighbor = coord + int2(dx, dy);
            if (neighbor.x >= 0 && neighbor.x < gridSize.x &&
                neighbor.y >= 0 && neighbor.y < gridSize.y)
            {
                float neighborDepth = WaterDepthTexture[neighbor].r;
                if (neighborDepth < MIN_DEPTH)
                {
                    nearShore = true;
                    shoreNormal += float2(dx, dy);
                    neighborCount++;
                }
            }
        }
    }
    
    if (nearShore && neighborCount > 0)
    {
        shoreNormal = normalize(shoreNormal);

        // Reflection coefficient (steep shores reflect more)
        float shoreSlope = length(float2(
            WaterDepthTexture[coord + int2(1, 0)].r - WaterDepthTexture[coord + int2(-1, 0)].r,
            WaterDepthTexture[coord + int2(0, 1)].r - WaterDepthTexture[coord + int2(0, -1)].r
        ));
        float reflectionCoeff = lerp(0.9f, 0.3f, saturate(shoreSlope / 0.5f));

        // PHASE 1.5: Enhanced sloshing - waves hitting walls bounce back harder
        // Check if waves are traveling toward the shore
        float waveTowardShore = dot(propagationDir, shoreNormal);
        if (waveTowardShore > 0.1f)
        {
            // Waves hitting the wall - create splash energy
            float impactEnergy = waveEnergy * waveTowardShore * SLOSH_REFLECTION_BOOST;
            waveEnergy += impactEnergy;

            // Wall impact creates foam and vorticity
            vorticity += waveTowardShore * 0.3f;
        }

        // Boost energy in reflection (creates standing waves/seiches)
        waveEnergy += waveEnergy * reflectionCoeff * 0.4f;
    }
    
    // ==========================================
    // 8. DEPTH REFRACTION (Shallow Water)
    // ==========================================
    if (depth < 10.0f && coord.x > 0 && coord.x < gridSize.x - 1 &&
        coord.y > 0 && coord.y < gridSize.y - 1)
    {
        float2 depthGradient = float2(
            WaterDepthTexture[coord + int2(1, 0)].r - WaterDepthTexture[coord + int2(-1, 0)].r,
            WaterDepthTexture[coord + int2(0, 1)].r - WaterDepthTexture[coord + int2(0, -1)].r
        ) * 0.5f;
        
        // Waves refract toward shallow areas (Snell's law)
        float refractionStrength = (10.0f - depth) / 10.0f;
        float2 refractionForce = depthGradient * refractionStrength * 0.2f;
        
        waveEnergy += dot(refractionForce, energyGradient) * DeltaTime;
    }
    
    // ==========================================
    // 9. DISSIPATION
    // ==========================================
    waveEnergy *= (1.0f - WaveParams.z * DeltaTime);  // Viscous dissipation
    
    // ==========================================
    // 10. GPU FOAM GENERATION (Preserved for Phase 2)
    // ==========================================
    // Generate foam from physical processes (GPU-only, no CPU cost)
    float flowSpeed = length(velocity);
    float foamFromWaves = saturate(waveHeight / max(depth, 0.1f)) * 0.3f;
    float vorticityFoam = saturate(abs(vorticity) * 2.0f);
    float breakingFoam = saturate(breakingEnergy * BREAKING_FOAM_BOOST);
    
    float totalFoam = saturate(foamFromWaves + vorticityFoam + breakingFoam);
    
    // ==========================================
    // OUTPUT: Write Results
    // ==========================================
    // Clamp values to prevent runaway
    waveEnergy = clamp(waveEnergy, 0.0f, 1000.0f);
    vorticity = clamp(vorticity, -10.0f, 10.0f);
    velocity = clamp(velocity, float2(-50.0f, -50.0f), float2(50.0f, 50.0f));
    
    // Write to FlowDataTexture (persistent state)
    FlowDataTexture[coord] = float4(
        velocity.x,   // R: Velocity X
        velocity.y,   // G: Velocity Y
        waveEnergy,   // B: Wave Energy (PHASE 1 NEW)
        vorticity     // A: Vorticity (PHASE 1 NEW)
    );
    
    // Write to WaveOutputTexture (for rendering)
    WaveOutputTexture[coord] = float4(
        waveHeight * WaveParams.x,  // R: Wave height (scaled)
        depth,                      // G: Water depth
        flowSpeed,                  // B: Flow speed
        totalFoam                   // A: Foam (GPU-generated, ready for Phase 2)
    );
}
