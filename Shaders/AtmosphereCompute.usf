// AtmosphereCompute.usf - Enhanced Weather Dynamics
// MILESTONES 3 + 4 + 5: Improved Buoyancy + Mountain Waves + SUSTAINED CIRCULATION
#include "/Engine/Public/Platform.ush"

#define THREADGROUP_SIZE 8
#define TWO_PI 6.28318530718
#define PI 3.14159265359

// Parameters from CPU
float DeltaTime;
float AccumulatedTime;
int2 GridSize;
float TerrainScale;
float OrographicLiftCoefficient;
float AdiabatiCoolingRate;
float RainShadowIntensity;
uint bForceInit;

// GPU-resident textures
RWTexture2D<float4> StateTexture;
RWTexture2D<float4> RenderTexture;
RWTexture2D<float2> WindFieldTexture;
RWTexture2D<float> PrecipitationTexture;

// Input textures
Texture2D<float> TerrainHeightTexture;
SamplerState TerrainSampler;

// ==========================================
// REVISED PHYSICS CONSTANTS - MILESTONE 5
// Rebalanced for sustained atmospheric circulation
// ==========================================

// Cloud physics - balanced for continuous regeneration
static const float CONDENSATION_RATE = 0.012;
static const float EVAPORATION_RATE = 0.008;
static const float PRECIPITATION_THRESHOLD = 0.65;
static const float CLOUD_DISSIPATION = 0.0008;  // REDUCED: was 0.002
static const float EVAPORATION_THRESHOLD = 0.9;

// Wind persistence - MUCH stronger momentum retention
static const float WIND_MOMENTUM = 0.98;  // INCREASED: was 0.96 (only 2% loss per frame)
static const float WIND_FORCING = 0.12;   // INCREASED: was 0.08 (stronger response)
static const float WIND_DIFFUSION = 0.02; // REDUCED: was 0.03 (less smoothing)
static const float WIND_DAMPING = 0.9995; // INCREASED: was 0.999 (minimal damping)
static const float VORTICITY_STRENGTH = 0.18; // INCREASED: was 0.15

// Weather dynamics - enhanced energy input
static const float SOLAR_CONSTANT = 0.5;  // INCREASED: was 0.3 (stronger heating)
static const float RAIN_COOLING_RATE = 0.3; // REDUCED: was 0.5 (slower cooling)
static const float EVAPORATION_COEFF = 0.003; // INCREASED: was 0.001 (more moisture)
static const float LATENT_HEAT_FACTOR = 6.0; // INCREASED: was 5.0
static const float THERMAL_EXPANSION = 0.006; // INCREASED: was 0.005 (stronger buoyancy)
static const float TURBULENCE_STRENGTH = 0.35; // INCREASED: was 0.4

// NEW: Large-scale circulation forcing
static const float PREVAILING_WIND_STRENGTH = 2.0;  // Strong base circulation
static const float PRESSURE_GRADIENT_STRENGTH = 0.8; // Temperature drives wind
static const float CONVECTIVE_CLOUD_FORMATION = 0.0018; // Cloud regeneration
static const float MOISTURE_ADVECTION_RATE = 0.15; // Horizontal moisture transport

// NEW: Differential heating parameters
static const float LAND_HEATING_FACTOR = 1.3;  // Land heats 30% more than water
static const float ELEVATION_COOLING_RATE = 0.4; // Higher elevation = cooler
static const float RADIATIVE_COOLING_RATE = 0.08; // Nighttime cooling

// Mountain wave constants (unchanged)
static const float BRUNT_VAISALA_FREQ = 0.01;
static const float WAVE_AMPLITUDE_SCALE = 0.2;
static const float WAVE_DECAY_DISTANCE = 3.0;

// NEW: Energy floor prevention
static const float MIN_WIND_ENERGY = 0.1;  // REDUCED threshold
static const float ENERGY_INJECTION_RATE = 0.03; // INCREASED injection
static const float WIND_NOISE_AMPLITUDE = 0.04; // Break symmetry

float ComputeSaturationPressure(float Temperature)
{
    float TempC = Temperature - 273.15;
    return 611.0 * exp((17.27 * TempC) / (TempC + 237.3));
}

float hash(float2 p)
{
    float3 p3 = frac(float3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

float noise(float2 p)
{
    float2 i = floor(p);
    float2 f = frac(p);
    f = f * f * (3.0 - 2.0 * f);
    
    float a = hash(i);
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));
    
    return lerp(lerp(a, b, f.x), lerp(c, d, f.x), f.y);
}

// ==========================================
// MILESTONE 4: ENHANCED OROGRAPHIC LIFT
// ==========================================
float2 CalculateOrographicLift(float2 UV, float2 Wind, out float2 TerrainGradient)
{
    float2 TexelSize = 1.0 / float2(GridSize);
    
    // Sample terrain heights
    float HeightC = TerrainHeightTexture.SampleLevel(TerrainSampler, UV, 0).r;
    float HeightL = TerrainHeightTexture.SampleLevel(TerrainSampler, UV + float2(-TexelSize.x, 0), 0).r;
    float HeightR = TerrainHeightTexture.SampleLevel(TerrainSampler, UV + float2(TexelSize.x, 0), 0).r;
    float HeightT = TerrainHeightTexture.SampleLevel(TerrainSampler, UV + float2(0, -TexelSize.y), 0).r;
    float HeightB = TerrainHeightTexture.SampleLevel(TerrainSampler, UV + float2(0, TexelSize.y), 0).r;
    
    TerrainGradient = float2(HeightR - HeightL, HeightB - HeightT) / (2.0 * TerrainScale);
    
    float WindSpeed = length(Wind);
    if (WindSpeed < 0.001)
        return float2(0, HeightC);
    
    float2 WindDir = normalize(Wind);
    
    // EXISTING: Basic orographic lift
    float VerticalVelocity = dot(WindDir, TerrainGradient) * WindSpeed * OrographicLiftCoefficient;
    
    // NEW MILESTONE 4: Mountain wave calculations
    float N = BRUNT_VAISALA_FREQ;
    float Nh0_U = (N * HeightC * TerrainScale) / max(WindSpeed, 0.1);
    
    if (Nh0_U > 0.3 && HeightC > 0.05)
    {
        float waveAmplitude = WindSpeed * Nh0_U * WAVE_AMPLITUDE_SCALE;
        float wavelength = (TWO_PI * WindSpeed) / N;
        wavelength *= TerrainScale;
        
        float maxHeight = HeightC;
        float2 peakOffset = float2(0, 0);
        
        for (int dy = -1; dy <= 1; dy++)
        {
            for (int dx = -1; dx <= 1; dx++)
            {
                float2 sampleUV = UV + float2(dx, dy) * TexelSize;
                float h = TerrainHeightTexture.SampleLevel(TerrainSampler, sampleUV, 0).r;
                if (h > maxHeight)
                {
                    maxHeight = h;
                    peakOffset = float2(dx, dy) * TexelSize;
                }
            }
        }
        
        float2 toPeak = peakOffset;
        float downwindDist = -dot(toPeak, WindDir) * GridSize.x * TerrainScale;
        
        if (downwindDist > 0.0)
        {
            float phase = (downwindDist / wavelength) * TWO_PI;
            float decay = exp(-downwindDist / (wavelength * WAVE_DECAY_DISTANCE));
            float waveContribution = waveAmplitude * sin(phase) * decay;
            VerticalVelocity += waveContribution;
        }
    }
    
    return float2(VerticalVelocity, HeightC);
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint2 PixelCoord = DispatchThreadId.xy;
    
    if (any(PixelCoord >= uint2(GridSize)))
        return;
    
    float2 UV = (float2(PixelCoord) + 0.5) / float2(GridSize);
    
    // Read current state
    float4 CurrentState = StateTexture[PixelCoord];

    // CPU-controlled initialization
    if (bForceInit == 1)
    {
        float cloudNoise = 0.0;
        float moistureNoise = sin(UV.x * 4.0) * cos(UV.y * 4.0) * 0.3 + 0.5;
        
        StateTexture[PixelCoord] = float4(
            0.0,
            moistureNoise,
            288.15 / 400.0,
            0.0
        );
        
        // REVISED: Stronger initial wind circulation
        float2 initialWind = float2(
            cos(UV.y * PI) * 0.5 + 0.3,
            sin(UV.x * TWO_PI) * 0.2
        );
        WindFieldTexture[PixelCoord] = initialWind;
        PrecipitationTexture[PixelCoord] = 0.0;
        return;
    }
    
    // Unpack state
    float CloudCover = CurrentState.r;
    float Moisture = CurrentState.g;
    float Temperature = CurrentState.b * 400.0;
    float Precipitation = CurrentState.a;
    
    // ==========================================
    // MILESTONE 5: ENHANCED SOLAR HEATING
    // Differential heating drives circulation
    // ==========================================
    float solarAngle = max(0.0, sin((AccumulatedTime * 0.0001) * TWO_PI));
    
    // NEW: Terrain-dependent heating
    float2 TerrainGradient;
    float2 OrographicData = CalculateOrographicLift(UV, WindFieldTexture[PixelCoord], TerrainGradient);
    float TerrainHeight = OrographicData.g;
    float isWater = (TerrainHeight < 0.1) ? 1.0 : 0.0;
    
    // Land heats more than water
    float terrainAbsorption = lerp(LAND_HEATING_FACTOR, 1.0, isWater);
    
    // Higher elevations are cooler
    float elevationCooling = saturate(TerrainHeight * ELEVATION_COOLING_RATE);
    
    float solarHeating = SOLAR_CONSTANT * solarAngle * (1.0 - CloudCover * 0.7);
    solarHeating *= terrainAbsorption * (1.0 - elevationCooling);
    Temperature += solarHeating * DeltaTime;
    
    // NEW: Radiative cooling at night
    float nightCooling = (1.0 - solarAngle) * RADIATIVE_COOLING_RATE;
    // Moisture and clouds retain heat
    nightCooling *= (1.0 - Moisture * 0.3) * (1.0 - CloudCover * 0.5);
    Temperature -= nightCooling * DeltaTime;
    
    // ==========================================
    // MILESTONE 5: SUSTAINED WIND DYNAMICS
    // ==========================================
    float2 WindCurrent = WindFieldTexture[PixelCoord];
    
    // NEW: Much stronger prevailing wind with temporal and spatial variation
    float2 baseWind = float2(
        cos(AccumulatedTime * 0.00003 + UV.y * PI * 0.5) * PREVAILING_WIND_STRENGTH,
        sin(AccumulatedTime * 0.00002 + UV.x * PI * 0.3) * PREVAILING_WIND_STRENGTH * 0.5
    );
    
    // Latitude-based circulation (Hadley cell proxy)
    float latitudeFactor = cos(UV.y * PI);
    float2 latitudeWind = float2(latitudeFactor * 0.8, 0.0);
    
    // Seasonal variation
    float2 seasonalVariation = float2(
        sin(AccumulatedTime * 0.00001) * 0.3,
        cos(AccumulatedTime * 0.000008) * 0.2
    );
    
    float2 persistentWind = (baseWind + latitudeWind + seasonalVariation) * WIND_FORCING;

    // Orographic lift
    float VerticalVelocity = OrographicData.r;
    
    // Sample neighbor winds
    int2 PixN = (int2(PixelCoord) + int2(0, -1) + int2(GridSize)) % int2(GridSize);
    int2 PixS = (int2(PixelCoord) + int2(0, 1) + int2(GridSize)) % int2(GridSize);
    int2 PixE = (int2(PixelCoord) + int2(1, 0) + int2(GridSize)) % int2(GridSize);
    int2 PixW = (int2(PixelCoord) + int2(-1, 0) + int2(GridSize)) % int2(GridSize);
    
    float2 WindN = WindFieldTexture[PixN];
    float2 WindS = WindFieldTexture[PixS];
    float2 WindE = WindFieldTexture[PixE];
    float2 WindW = WindFieldTexture[PixW];
    
    float2 WindAvg = (WindN + WindS + WindE + WindW) * 0.25;
    
    // Vorticity confinement
    float2 gradX = (WindE - WindW) * 0.5;
    float2 gradY = (WindN - WindS) * 0.5;
    float vorticity = gradX.y - gradY.x;
    
    float2 vorticityGrad = float2(
        ((WindE.y - WindW.y) - (WindE.x - WindW.x)) * 0.5,
        ((WindN.y - WindS.y) - (WindN.x - WindS.x)) * 0.5
    );
    float vorticityMag = length(vorticityGrad);
    
    float2 vorticityForce = float2(0, 0);
    if (vorticityMag > 0.0001)
    {
        float2 N = normalize(vorticityGrad);
        vorticityForce = VORTICITY_STRENGTH * float2(-N.y, N.x) * vorticity;
    }
    
    // Multi-scale turbulence
    float2 turbulence = float2(0, 0);
    float amplitude = TURBULENCE_STRENGTH;
    float frequency = 2.0;
    float2 timeOffset = float2(AccumulatedTime * 0.01, AccumulatedTime * 0.0137);
    
    for (int octave = 0; octave < 3; octave++)
    {
        float2 samplePos = UV * frequency + timeOffset;
        float2 n = float2(
            noise(samplePos) * 2.0 - 1.0,
            noise(samplePos + 100.0) * 2.0 - 1.0
        );
        turbulence += n * amplitude;
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    
    // ==========================================
    // MILESTONE 3 + 5: ENHANCED BUOYANCY
    // ==========================================
    float ambientTemp = 288.15;
    float tempAnomaly = Temperature - ambientTemp;
    float2 buoyancyForce = float2(0, 0);
    
    float4 StateN = StateTexture[PixN];
    float4 StateS = StateTexture[PixS];
    float4 StateE = StateTexture[PixE];
    float4 StateW = StateTexture[PixW];
    
    float TempN = StateN.b * 400.0;
    float TempS = StateS.b * 400.0;
    float TempE = StateE.b * 400.0;
    float TempW = StateW.b * 400.0;
    
    // Temperature gradient (hot to cold creates pressure gradient)
    float2 tempGradient = float2(TempE - TempW, TempN - TempS) * 0.5;
    float tempGradMag = length(tempGradient);
    
    // NEW: Enhanced pressure gradient forcing
    if (tempGradMag > 0.005)
    {
        float2 pressureGradient = -normalize(tempGradient + float2(0.001, 0.001));
        float pressureForceStrength = tempGradMag * PRESSURE_GRADIENT_STRENGTH;
        buoyancyForce += pressureGradient * pressureForceStrength;
    }
    
    // Temperature-driven buoyancy
    if (abs(tempAnomaly) > 1.5)
    {
        float2 pressureGradient = -normalize(tempGradient + float2(0.001, 0.001));
        float buoyancyStrength = tempAnomaly * THERMAL_EXPANSION;
        buoyancyForce += pressureGradient * buoyancyStrength;
        
        if (tempAnomaly > 3.0)
        {
            float divergence = 0.015 * (tempAnomaly - 3.0);
            buoyancyForce += normalize(WindCurrent + float2(0.001, 0.001)) * divergence;
        }
    }
    
    // Integrate wind forces with STRONGER persistence
    float2 WindNew = WindCurrent * WIND_MOMENTUM;
    WindNew += vorticityForce * WIND_FORCING;
    WindNew += turbulence * WIND_FORCING;
    WindNew += buoyancyForce * WIND_FORCING;
    WindNew += persistentWind;
    WindNew = lerp(WindNew, WindAvg, WIND_DIFFUSION);
    WindNew *= WIND_DAMPING;
    
    // NEW: Energy floor prevention - maintain minimum circulation
    float windSpeed = length(WindNew);
    if (windSpeed < MIN_WIND_ENERGY)
    {
        float2 energyBoost = normalize(WindNew + float2(0.001, 0.001)) * ENERGY_INJECTION_RATE;
        WindNew += energyBoost;
        
        // Add spatial noise to break symmetry
        float2 randomPush = float2(
            hash(UV + AccumulatedTime * 0.001) - 0.5,
            hash(UV.yx + AccumulatedTime * 0.001) - 0.5
        ) * WIND_NOISE_AMPLITUDE;
        WindNew += randomPush;
    }
    
    // Soft velocity capping
    windSpeed = length(WindNew);
    if (windSpeed > 2.8)
    {
        WindNew = normalize(WindNew) * (2.8 + (windSpeed - 2.8) * 0.25);
    }
    
    // ==========================================
    // ADVECTION
    // ==========================================
    float2 CloudOffset = WindNew * DeltaTime * 0.001;
    float2 CloudUV = UV - CloudOffset;
    CloudUV = frac(CloudUV + float2(1.0, 1.0));
    
    float2 CloudPixel = CloudUV * float2(GridSize) - 0.5;
    int2 CloudBase = int2(floor(CloudPixel));
    float2 CloudFrac = frac(CloudPixel);
    
    int2 P00 = (CloudBase + GridSize) % GridSize;
    int2 P10 = ((CloudBase + int2(1, 0)) + GridSize) % GridSize;
    int2 P01 = ((CloudBase + int2(0, 1)) + GridSize) % GridSize;
    int2 P11 = ((CloudBase + int2(1, 1)) + GridSize) % GridSize;
    
    float4 S00 = StateTexture[P00];
    float4 S10 = StateTexture[P10];
    float4 S01 = StateTexture[P01];
    float4 S11 = StateTexture[P11];
    
    float4 AdvectedState = lerp(
        lerp(S00, S10, CloudFrac.x),
        lerp(S01, S11, CloudFrac.x),
        CloudFrac.y
    );
    
    CloudCover = AdvectedState.r;
    Moisture = AdvectedState.g;
    
    // ==========================================
    // MILESTONE 5: ENHANCED CLOUD PHYSICS
    // Continuous regeneration balances dissipation
    // ==========================================
    float SaturationPressure = ComputeSaturationPressure(Temperature);
    float CurrentVaporPressure = Moisture * SaturationPressure;
    
    // Standard condensation
    if (CurrentVaporPressure > SaturationPressure * 0.95)
    {
        float Condensation = (CurrentVaporPressure - SaturationPressure) / SaturationPressure;
        Condensation = min(Condensation * CONDENSATION_RATE, Moisture);
        CloudCover += Condensation;
        Moisture -= Condensation;
        Temperature += Condensation * 2.0 * DeltaTime;
    }
    
    // Orographic enhancement
    if (VerticalVelocity > 0.01)
    {
        float OrographicCondensation = VerticalVelocity * Moisture * 0.5;
        CloudCover += OrographicCondensation * DeltaTime;
        Moisture = max(Moisture - OrographicCondensation * DeltaTime, 0.0);
        Temperature -= OrographicCondensation * AdiabatiCoolingRate * DeltaTime;
    }
    
    // NEW: Convective cloud formation (warm updrafts)
    if (tempAnomaly > 2.5 && Moisture > 0.25)
    {
        float convectiveCondensation = (tempAnomaly - 2.5) * Moisture * CONVECTIVE_CLOUD_FORMATION;
        CloudCover += convectiveCondensation * DeltaTime;
        Moisture -= convectiveCondensation * DeltaTime * 0.6;
        Temperature += convectiveCondensation * LATENT_HEAT_FACTOR * DeltaTime * 0.3;
    }
    
    // NEW: Enhanced evaporation over water with stronger feedback
    if (isWater > 0.5)
    {
        float evapRate = EVAPORATION_COEFF * (Temperature / 288.15) * (1.0 + windSpeed / 8.0);
        evapRate *= (1.0 - Moisture * 0.7);  // Less evap if already saturated
        Moisture = min(Moisture + evapRate * DeltaTime, 1.0);
        Temperature -= evapRate * LATENT_HEAT_FACTOR * DeltaTime;
    }
    
    // NEW: Horizontal moisture advection (critical for valley fog)
    float MoistureN = StateN.g;
    float MoistureS = StateS.g;
    float MoistureE = StateE.g;
    float MoistureW = StateW.g;
    
    float2 moistureGradient = float2(MoistureE - MoistureW, MoistureN - MoistureS) * 0.5;
    float moistureAdvection = dot(normalize(WindNew + float2(0.001, 0.001)), moistureGradient);
    Moisture += moistureAdvection * windSpeed * MOISTURE_ADVECTION_RATE * DeltaTime;
    
    // Precipitation
    if (CloudCover > PRECIPITATION_THRESHOLD)
    {
        float RainRate = (CloudCover - PRECIPITATION_THRESHOLD) * 0.05;
        Precipitation = min(Precipitation + RainRate, 1.0);
        CloudCover -= RainRate * 0.5;
        Moisture = max(Moisture - RainRate * 0.3, 0.0);
    }
    else
    {
        Precipitation *= 0.95;
    }
    
    // Rain cooling (REDUCED for slower equilibration)
    if (Precipitation > 0.01)
    {
        float coolingRate = Precipitation * RAIN_COOLING_RATE;
        Temperature = max(Temperature - coolingRate * DeltaTime, 250.0);
    }
    
    // NEW: Reduced dissipation with wind-dependent factor
    float dissipationFactor = lerp(0.6, 1.0, saturate(windSpeed / 2.0));
    CloudCover = max(CloudCover - CLOUD_DISSIPATION * DeltaTime * dissipationFactor, 0.0);
    
    // ==========================================
    // SAFETY & OUTPUT
    // ==========================================
    CloudCover = saturate(CloudCover);
    Moisture = saturate(Moisture);
    Temperature = clamp(Temperature, 200.0, 350.0);
    Precipitation = saturate(Precipitation);
    
    if (isnan(CloudCover + Moisture + Temperature + Precipitation))
    {
        CloudCover = 0.5;
        Moisture = 0.5;
        Temperature = 288.15;
        Precipitation = 0.0;
    }
    
    StateTexture[PixelCoord] = float4(
        CloudCover,
        Moisture,
        Temperature / 400.0,
        Precipitation
    );
    
    WindFieldTexture[PixelCoord] = WindNew;
    PrecipitationTexture[PixelCoord] = Precipitation;
    
    // ==========================================
    // VISUAL RENDERING
    // ==========================================
    float3 CloudColor = float3(1.0, 1.0, 1.0);
    
    float Darkness = 1.0;
    if (Precipitation > 0.01) {
        Darkness = lerp(1.0, 0.3, saturate(Precipitation * 2.0));
    } else if (CloudCover > 0.5) {
        Darkness = lerp(1.0, 0.7, (CloudCover - 0.5) * 2.0);
    }
    
    CloudColor *= Darkness;
    
    float3 ColdTint = float3(0.9, 0.95, 1.0);
    float3 WarmTint = float3(1.0, 0.98, 0.9);
    float TempNorm = saturate((Temperature - 273.15) / 30.0);
    CloudColor *= lerp(ColdTint, WarmTint, TempNorm);
    
    float Shimmer = sin(AccumulatedTime * 2.0 + UV.x * 10.0) * 0.05 + 1.0;
    CloudColor *= Shimmer;
    
    float FinalAlpha = CloudCover * 1.5;
    FinalAlpha = saturate(FinalAlpha);
    
    RenderTexture[PixelCoord] = float4(CloudColor * FinalAlpha, FinalAlpha);
}
